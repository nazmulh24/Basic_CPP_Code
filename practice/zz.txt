{
	"cpp": {
		"prefix": "cppp",
		"body": [
			"/***********************************************************************",
			"",
			"Name --> ",
			"Link --> ",
			"",
			"Example--> ",
			"",
			"------------------------------------------------------------------------",
			"Author --> Nazmul Hossain",
			"***********************************************************************/",
			"",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define int long long",
			"#define no cout << \"NO\" << '\\n'",
			"#define yes cout << \"YES\" << '\\n'",
			"#define endl '\\n'",
			"#define all(x) (x).begin(), (x).end()",
			"#define rall(x) (x).rbegin(), (x).rend()",
			"#define sz(x) ((int)(x).size())",
			"#define pb push_back",
			"#define pf push_front",
			"#define mp make_pair",
			"#define mt make_tuple",
			"#define fi first",
			"#define se second",
			"#define forl(i, a, b) for (auto i = (a); i <= (b); ++i)",
			"#define rfor(i, b, a) for (auto i = (b); i >= (a); --i)",
			"#define trav(a, x) for (auto &a : x)",
			"#define UNIQUE(v) v.erase(unique(all(v)), v.end())",
			"//********************************************************************",
			"",
			"bool isPrime(int n)",
			"{",
			"    if (n == 1)",
			"        return false;",
			"",
			"    for (int i = 2; i * i <= n; i++)",
			"    {",
			"        if (n % i == 0)",
			"            return false;",
			"    }",
			"",
			"    return true;",
			"}",
			"",
			"int GCD(int a, int b)",
			"{",
			"    return __gcd(a, b); //--> O(log(min(a, b)))",
			"}",
			"",
			"int LCM(int a, int b)",
			"{",
			"    return (a / __gcd(a, b)) * b; //--> O(log(min(a, b)))",
			"}",
			"",
			"void PSUM(vector<int> a, vector<int> &pSum)",
			"{",
			"    int n = sz(a);",
			"    pSum[0] = a[0];",
			"    forl(i,1, n)",
			"    {",
			"        pSum[i] = pSum[i - 1] + a[i];",
			"    }",
			"}",
			"",
			"//********************************************************************",
			"",
			"void solve()",
			"{",
			"    int n;",
			"    cin >> n;",
			"    ",
			"}",
			"",
			"int32_t main()",
			"{",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(0);",
			"",
			"    int ttttt = 1;",
			"    // cin >> ttttt; //--> Uncomment if multiple test cases",
			"",
			"    while (ttttt--)",
			"    {",
			"        solve();",
			"    }",
			"",
			"    return 0;",
			"}",
			""
		],
		"description": ""
	},
	"scc_kosaraju": {
		"prefix": "nscc",
		"body": [
			"/***********************************************************************",
			"",
			"Name --> Given a directed graph, write a program to find Strongly Connected Components (SCCs)",
			"using Kosaraju’s algorithm.",
			"",
			"--> Only Valid for Directed Graph",
			"--> Negetive weight cycle handle korte pare na!!!...",
			"",
			"***********************************************************************/",
			"",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define int long long",
			"#define endl '\\n'",
			"",
			"int const N = 1e5 + 5;",
			"",
			"vector<int> adj[N];  // Original graph",
			"vector<int> adjT[N]; // Transposed graph",
			"bool vis[N];         // Visited array",
			"stack<int> st;       // Stack to store the order of nodes",
			"",
			"void dfs(int node)",
			"{",
			"    vis[node] = true;",
			"",
			"    for (auto it : adj[node])",
			"    {",
			"        if (!vis[it])",
			"            dfs(it);",
			"    }",
			"",
			"    st.push(node);",
			"}",
			"",
			"void dfs_back(int node)",
			"{",
			"    vis[node] = true;",
			"",
			"    cout << node << \" \";",
			"",
			"    for (auto it : adjT[node])",
			"    {",
			"        if (!vis[it])",
			"            dfs_back(it);",
			"    }",
			"}",
			"",
			"int kosaraju(int v)",
			"{",
			"    //--> Step 1: Perform DFS and fill the stack",
			"    for (int i = 1; i <= v; ++i)",
			"    {",
			"        if (!vis[i])",
			"            dfs(i);",
			"    }",
			"",
			"    //--> Step 2: Transpose the graph",
			"    for (int i = 1; i <= v; ++i)",
			"    {",
			"        for (auto it : adj[i])",
			"        {",
			"            adjT[it].push_back(i);",
			"        }",
			"    }",
			"",
			"    //--> Step 3: Find SCCs using DFS on the transposed graph",
			"",
			"    memset(vis, false, sizeof(vis)); // Reset the visited array",
			"    int scc = 0;",
			"",
			"    while (!st.empty())",
			"    {",
			"        int node = st.top();",
			"        st.pop();",
			"",
			"        if (!vis[node])",
			"        {",
			"            scc++;",
			"",
			"            cout << scc << \" SCC is : \";",
			"",
			"            dfs_back(node); // Perform DFS on the transposed graph",
			"            cout << endl;",
			"        }",
			"    }",
			"",
			"    return scc;",
			"}",
			"",
			"int32_t main()",
			"{",
			"    int n, e;",
			"    cin >> n >> e;",
			"",
			"    while (e--)",
			"    {",
			"        int a, b;",
			"        cin >> a >> b;",
			"        adj[a].push_back(b);",
			"    }",
			"",
			"    memset(vis, false, sizeof(vis));",
			"    // for (int i = 0; i < N; i++)",
			"    // {",
			"    //     vis[i] = false;",
			"    // }",
			"",
			"    int ans = kosaraju(n);",
			"",
			"    cout << \"The Number of SCC is : \" << ans << endl;",
			"",
			"    return 0;",
			"}",
			""
		],
		"description": "scc_kosaraju"
	},
	"bell_man": {
		"prefix": "nbmf",
		"body": [
			"/***********************************************************************",
			"",
			"Name --> Implement the Bellman-Ford algorithm to find the shortest path from a single source vertex.",
			"",
			"--> Negetive weight cycle handle korte pare...",
			"",
			"***********************************************************************/",
			"",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define int long long",
			"#define endl '\\n'",
			"#define INF LLONG_MAX",
			"//********************************************************************",
			"",
			"class Edge",
			"{",
			"public:",
			"    int u, v, c;",
			"",
			"    Edge(int u, int v, int c)",
			"    {",
			"        this->u = u;",
			"        this->v = v;",
			"        this->c = c;",
			"    }",
			"};",
			"",
			"const int N = 1e5 + 5;",
			"int dis[N];",
			"",
			"void bellmanFord(int n, int src, vector<Edge> &edgeList)",
			"{",
			"    dis[src] = 0;",
			"",
			"    for (int i = 0; i < n - 1; i++)",
			"    {",
			"        for (auto ed : edgeList)",
			"        {",
			"            int u, v, c;",
			"",
			"            u = ed.u;",
			"            v = ed.v;",
			"            c = ed.c;",
			"",
			"            if (dis[u] < INF && dis[u] + c < dis[v])",
			"                dis[v] = dis[u] + c;",
			"        }",
			"    }",
			"",
			"    for (auto edge : edgeList)",
			"    {",
			"        int u, v, c;",
			"",
			"        u = edge.u;",
			"        v = edge.v;",
			"        c = edge.c;",
			"",
			"        if (dis[u] < INF && dis[u] + c < dis[v])",
			"        {",
			"            cout << \"There is a Negative Cycle!!!\" << endl;",
			"            return;",
			"        }",
			"    }",
			"",
			"    for (int i = 1; i <= n; i++)",
			"    {",
			"        cout << i << \" -> \";",
			"",
			"        if (dis[i] == INF)",
			"            cout << \"INF\" << endl;",
			"        else",
			"            cout << dis[i] << endl;",
			"    }",
			"}",
			"",
			"int32_t main()",
			"{",
			"    int n, e;",
			"    cin >> n >> e;",
			"",
			"    vector<Edge> edgeList;",
			"",
			"    while (e--)",
			"    {",
			"        int a, b, c;",
			"        cin >> a >> b >> c;",
			"        edgeList.push_back(Edge(a, b, c));",
			"    }",
			"",
			"    // for (int i = 0; i <= n; i++)",
			"    //     dis[i] = INT_MAX;",
			"    fill(dis, dis + N, INF);",
			"",
			"    int src = 1;",
			"    bellmanFord(n, src, edgeList);",
			"",
			"    return 0;",
			"}",
			""
		],
		"description": "bell_man"
	},
	"krushkals_mst": {
		"prefix": "nkmst",
		"body": [
			"/***********************************************************************",
			"",
			"Name --> Implement Kruskal’s algorithm to find the Minimum Spanning Tree (MST).",
			"",
			"***********************************************************************/",
			"",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"",
			"#define endl '\\n'",
			"#define fi first",
			"#define se second",
			"",
			"//--> Find the parent of the node",
			"int find_Parent(vector<int> &parent, int i)",
			"{",
			"    if (parent[i] == i)",
			"        return i;",
			"",
			"    return parent[i] = find_Parent(parent, parent[i]);",
			"}",
			"",
			"//--> Union the sets",
			"void unionSets(vector<int> &parent, vector<int> &rank, int x, int y)",
			"{",
			"    int rootX = find_Parent(parent, x);",
			"    int rootY = find_Parent(parent, y);",
			"",
			"    if (rank[rootX] < rank[rootY])",
			"        parent[rootX] = rootY;",
			"    else if (rank[rootX] > rank[rootY])",
			"        parent[rootY] = rootX;",
			"    else",
			"    {",
			"        parent[rootY] = rootX;",
			"        rank[rootX]++;",
			"    }",
			"}",
			"",
			"//--> Kruskal's algorithm for MST",
			"void kruskal_MST(int v, vector<pair<int, pair<int, int>>> &edges)",
			"{",
			"    sort(edges.begin(), edges.end()); //--> Sort edges by weight",
			"",
			"    vector<int> parent(v), rank(v, 0);",
			"    vector<pair<int, pair<int, int>>> mst;",
			"",
			"    for (int i = 0; i < v; i++) //--> Initialize parent array",
			"        parent[i] = i;",
			"",
			"    for (auto edge : edges) //--> Process each edge",
			"    {",
			"        int w = edge.fi;",
			"        int u = edge.se.fi;",
			"        int v = edge.se.se;",
			"",
			"        int rootU = find_Parent(parent, u);",
			"        int rootV = find_Parent(parent, v);",
			"",
			"        if (rootU != rootV)",
			"        {",
			"            mst.push_back({w, {u, v}});",
			"            unionSets(parent, rank, rootU, rootV);",
			"        }",
			"    }",
			"",
			"    cout << \"Minimum Spanning Tree :\" << endl;",
			"",
			"    for (auto edge : mst)",
			"    {",
			"        cout << \"Edge (\" << edge.se.fi << \", \" << edge.se.se << \") with weight \" << edge.fi << endl;",
			"    }",
			"}",
			"",
			"int main()",
			"{",
			"    int v, e;",
			"    cin >> v >> e;",
			"",
			"    vector<pair<int, pair<int, int>>> edges;",
			"",
			"    while (e--)",
			"    {",
			"        int u, v, w;",
			"        cin >> u >> v >> w;",
			"        edges.push_back({w, {u, v}});",
			"    }",
			"",
			"    kruskal_MST(v, edges);",
			"",
			"    return 0;",
			"}",
			""
		],
		"description": "krushkals_mst"
	}
}